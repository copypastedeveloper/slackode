#!/bin/bash
set -e

# ── Provider configuration ──
PROVIDER="${PROVIDER:-github-copilot}"
MODEL="${MODEL:-claude-sonnet-4.6}"

# ── Neutralize the target repo's own agent/skill/plugin files ──
# Some repos ship their own .opencode/agents/, .opencode/plugin/,
# and .claude/skills/ directories. OpenCode auto-discovers and loads these,
# causing the agent to behave as a development assistant (editing files,
# spawning subagents, loading skills). We must remove them after every
# clone/pull so the agent stays read-only.
clean_repo_agents() {
  local repo="$1"
  echo "Cleaning repo agent/skill/plugin files..."
  rm -rf "$repo/.opencode/agents"
  rm -rf "$repo/.opencode/plugin"
  rm -rf "$repo/.opencode/plugins"
  rm -rf "$repo/.claude/skills"
  rm -rf "$repo/.claude"
  rm -rf "$repo/.agents"
  # Also remove any nested .opencode config that could override ours
  rm -f "$repo/.opencode/opencode.json"
  rm -f "$repo/.opencode/.opencode"
  echo "Repo agent/skill/plugin files cleaned."
}

# ── Pre-seed OpenCode auth ──
# Only github-copilot requires a pre-seeded auth.json (OAuth token).
# Other providers use standard API key env vars that OpenCode reads directly.
if [ "$PROVIDER" = "github-copilot" ]; then
  if [ -n "$COPILOT_TOKEN" ]; then
    AUTH_DIR="$HOME/.local/share/opencode"
    mkdir -p "$AUTH_DIR"
    # Use printf to safely embed the token without shell interpretation
    printf '{"github-copilot":{"type":"oauth","access":"%s","refresh":"%s","expires":0}}\n' \
      "$COPILOT_TOKEN" "$COPILOT_TOKEN" > "$AUTH_DIR/auth.json"
    echo "Copilot auth.json written to $AUTH_DIR/auth.json"
  else
    echo "ERROR: COPILOT_TOKEN is required when PROVIDER=github-copilot"
    echo "Run 'opencode auth login' locally, then copy the gho_ token from ~/.local/share/opencode/auth.json"
    exit 1
  fi
fi

# ── Validate provider-specific requirements ──
case "$PROVIDER" in
  github-copilot) ;;  # handled above
  anthropic)
    [ -z "$ANTHROPIC_API_KEY" ] && echo "ERROR: ANTHROPIC_API_KEY is required when PROVIDER=anthropic" && exit 1 ;;
  openai)
    [ -z "$OPENAI_API_KEY" ] && echo "ERROR: OPENAI_API_KEY is required when PROVIDER=openai" && exit 1 ;;
  amazon-bedrock)
    [ -z "$AWS_REGION" ] && echo "WARNING: AWS_REGION is not set — Bedrock may fail." ;;
  google-vertex-ai)
    [ -z "$GOOGLE_CLOUD_PROJECT" ] && echo "WARNING: GOOGLE_CLOUD_PROJECT is not set — Vertex AI may fail." ;;
  *)
    echo "Using provider: $PROVIDER — ensure its API key env var is set." ;;
esac
echo "Provider: $PROVIDER, Model: $MODEL"

# ── Clone or update the repo ──
# Support legacy TARGET_REPO by constructing REPO_URL from it
if [ -z "$REPO_URL" ] && [ -n "$TARGET_REPO" ]; then
  REPO_URL="https://github.com/${TARGET_REPO}.git"
fi

if [ -z "$REPO_URL" ]; then
  echo "ERROR: REPO_URL is not set (e.g. REPO_URL=https://github.com/your-org/your-repo.git)"
  exit 1
fi

# Derive display name from URL if TARGET_REPO is not set
# e.g. https://gitlab.com/group/repo.git → group/repo
if [ -z "$TARGET_REPO" ]; then
  TARGET_REPO="$(echo "$REPO_URL" | sed -E 's|^https?://[^/]+/||; s|\.git$||')"
fi
export TARGET_REPO

# GIT_TOKEN with fallback to legacy GITHUB_TOKEN
GIT_TOKEN="${GIT_TOKEN:-$GITHUB_TOKEN}"

if [ -n "$GIT_TOKEN" ]; then
  # Use GIT_ASKPASS to supply credentials without embedding them in the URL
  # or persisting them in .git/config
  GIT_ASKPASS_SCRIPT="$(mktemp)"
  printf '#!/bin/sh\necho "%s"\n' "$GIT_TOKEN" > "$GIT_ASKPASS_SCRIPT"
  chmod +x "$GIT_ASKPASS_SCRIPT"
  export GIT_ASKPASS="$GIT_ASKPASS_SCRIPT"
  export GIT_TERMINAL_PROMPT=0
else
  echo "WARNING: GIT_TOKEN is not set — clone may fail for private repos."
fi

if [ ! -d /app/repo/.git ]; then
  echo "Cloning ${TARGET_REPO}..."
  git clone "$REPO_URL" /app/repo
else
  # Ensure the remote URL doesn't contain embedded credentials from a prior run
  git -C /app/repo remote set-url origin "$REPO_URL"
  echo "Updating ${TARGET_REPO}..."
  git -C /app/repo pull || echo "Pull failed, continuing with existing checkout."
fi

# ── Neutralize repo's own agents/skills/plugins ──
clean_repo_agents /app/repo

# ── Copy OpenCode rules into the repo directory ──
# opencode serve uses the cwd for config, so .opencode/rules/ needs to be
# present where the server runs. opencode.json is generated by Node on boot.
mkdir -p /app/repo/.opencode/rules
cp /app/.opencode/rules/*.md /app/repo/.opencode/rules/

# ── Background repo updater (every hour) ──
# Pulls latest code and cleans repo agents/skills/plugins.
# Context regeneration is handled by the bot process (via OpenCode agent).
# Note: opencode.json is generated by Node on boot and on tool config changes,
# so we don't copy it here.
(
  while true; do
    sleep 3600
    echo "[repo-sync] Pulling latest ${TARGET_REPO}..."
    if git -C /app/repo pull --ff-only 2>&1 | sed 's/^/[repo-sync] /'; then
      echo "[repo-sync] Cleaning repo agent/skill/plugin files..."
      clean_repo_agents /app/repo
      echo "[repo-sync] Repo updated. Context regeneration will be triggered by the bot."
    else
      echo "[repo-sync] Pull failed, will retry next cycle."
    fi
  done
) &
echo "Background repo sync started (every 60 min)."

# ── Start the Slack bot ──
# The bot now manages the OpenCode server lifecycle (start, restart on config changes).
cd /app
exec node dist/index.js
